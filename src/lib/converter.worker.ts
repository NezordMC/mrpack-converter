import JSZip from "jszip";
import pLimit from "p-limit";
import { ModrinthManifestSchema } from "./types";
import type { ModrinthManifest, ModrinthFile, WorkerMessage, WorkerResponse } from "./types";

const ctx: Worker = self as any;

let isPaused = false;
let resumeResolver: (() => void) | null = null;

ctx.onmessage = async (event: MessageEvent<WorkerMessage>) => {
  const { type } = event.data;

  try {
    if (type === "READ_MANIFEST") {
      const data = event.data as { file: File };
      const manifest = await readManifest(data.file);
      ctx.postMessage({ type: "MANIFEST_READ", manifest } satisfies WorkerResponse);
    } else if (type === "CONVERT") {
      isPaused = false;
      const data = event.data as { file: File; manifest: ModrinthManifest; options: { serverMode: boolean; selectedLoader: string } };
      await convert(data.file, data.manifest, data.options);
    } else if (type === "PAUSE") {
      isPaused = true;
    } else if (type === "RESUME") {
      isPaused = false;
      if (resumeResolver) {
        resumeResolver();
        resumeResolver = null;
      }
    }
  } catch (err) {
    ctx.postMessage({
      type: "ERROR",
      error: err instanceof Error ? err.message : "Unknown error occurred in worker",
    } satisfies WorkerResponse);
  }
};

async function checkPauseState() {
  if (isPaused) {
    await new Promise<void>((resolve) => {
      resumeResolver = resolve;
    });
  }
}

async function readManifest(file: File): Promise<ModrinthManifest> {
  try {
    const zip = await JSZip.loadAsync(file);
    const manifestFile = zip.file("modrinth.index.json");

    if (!manifestFile) {
      throw new Error("Invalid MrPack: modrinth.index.json not found in archive.");
    }

    const manifestContent = await manifestFile.async("string");
    const json = JSON.parse(manifestContent);

    const parsed = ModrinthManifestSchema.parse(json);
    return parsed;
  } catch (err: any) {
    if (err.name === "ZodError") {
      const field = err.issues[0]?.path.join(".") || "unknown field";
      throw new Error(`Invalid Manifest structure: Error in field '${field}' - ${err.issues[0]?.message}`);
    }
    if (err.message.includes("Corrupted zip")) {
      throw new Error("File is corrupted or not a valid ZIP archive.");
    }
    throw err;
  }
}

async function convert(file: File, manifest: ModrinthManifest, options: { serverMode: boolean; selectedLoader: string }) {
  const CACHE_NAME = "mrpack-mods-cache-v1";
  const cache = await caches.open(CACHE_NAME);

  const newZip = new JSZip();
  const originalZip = await JSZip.loadAsync(file);
  const limit = pLimit(5);

  const totalFiles = manifest.files.length;
  let completed = 0;
  const startTime = Date.now();

  postProgress("Copying overrides/configs...", 5, 0);

  const overridesDir = "overrides";
  originalZip.folder(overridesDir)?.forEach((relativePath, zipEntry) => {
    if (!zipEntry.dir) {
      newZip.file(relativePath, zipEntry.async("blob"));
    }
  });

  if (options.serverMode) {
    postProgress("Generating server scripts...", 8, 0);

    const batContent = `@echo off\nREM Auto-generated by MrPack Converter\njava -Xmx4G -jar ${options.selectedLoader} nogui\nPAUSE`;
    newZip.file("start.bat", batContent);

    const shContent = `#!/bin/sh\n# Auto-generated by MrPack Converter\njava -Xmx4G -jar ${options.selectedLoader} nogui`;
    newZip.file("start.sh", shContent, { unixPermissions: "755" });

    newZip.file("SERVER-README.txt", `Please rename your ${options.selectedLoader} jar to match the script or edit the script.`);
  }

  const downloadPromises = manifest.files.map((modFile: ModrinthFile) => {
    return limit(async () => {
      await checkPauseState();

      const fileName = modFile.path.split("/").pop() || "unknown.jar";
      const downloadUrl = modFile.downloads[0];

      if (!downloadUrl) {
        completed++;
        return;
      }

      try {
        const now = Date.now();
        const elapsedTime = (now - startTime) / 1000;
        const filesPerSecond = completed > 0 ? completed / elapsedTime : 0;
        const remainingFiles = totalFiles - completed;
        const etaSeconds = filesPerSecond > 0 ? remainingFiles / filesPerSecond : 0;

        postProgress(`Downloading ${fileName}...`, 10 + (completed / totalFiles) * 80, etaSeconds);

        let fileBlob: Blob;
        const cachedResponse = await cache.match(downloadUrl);

        if (cachedResponse) {
          fileBlob = await cachedResponse.blob();
        } else {
          const response = await fetch(downloadUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          cache.put(downloadUrl, response.clone());
          fileBlob = await response.blob();
        }

        newZip.file(modFile.path, fileBlob);
        completed++;
      } catch (err) {
        console.error(`Failed to download ${fileName}`, err);
        postProgress(`FAILED: ${fileName} (Skipping)`, 10 + (completed / totalFiles) * 80, 0);
      }
    });
  });

  await Promise.all(downloadPromises);

  postProgress("Compressing and Streaming ZIP...", 95, 0);

  const suffix = options.serverMode ? "SERVER-PACK" : "FULL";
  const finalFileName = `${manifest.name}-${manifest.versionId}-${suffix}.zip`;

  const zipStream = new ReadableStream({
    start(controller) {
      newZip
        .generateInternalStream({ type: "uint8array" })
        .on("data", (data) => {
          controller.enqueue(data);
        })
        .on("error", (err) => {
          controller.error(err);
        })
        .on("end", () => {
          controller.close();
        })
        .resume();
    },
  });

  ctx.postMessage(
    {
      type: "DONE",
      stream: zipStream,
      fileName: finalFileName,
    } satisfies WorkerResponse,
    [zipStream]
  );
}

function postProgress(log: string, progress: number, eta: number) {
  ctx.postMessage({ type: "PROGRESS", log, progress, eta } satisfies WorkerResponse);
}
