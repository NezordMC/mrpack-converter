import JSZip from "jszip";
import pLimit from "p-limit";
import saveAs from "file-saver";
import type { ModrinthManifest, ModrinthFile, ConversionOptions } from "./types";

type ProgressCallback = (log: string, progress: number) => void;

export class ConverterEngine {
  static async downloadFileFromUrl(url: string): Promise<File> {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to download file: ${response.statusText}`);
    const blob = await response.blob();
    const fileName = url.split("/").pop() || "modpack.mrpack";
    return new File([blob], fileName, { type: "application/octet-stream" });
  }

  static async readManifest(file: File): Promise<ModrinthManifest> {
    try {
      const zip = await JSZip.loadAsync(file);
      const manifestFile = zip.file("modrinth.index.json");
      if (!manifestFile) throw new Error("modrinth.index.json not found.");
      const manifestContent = await manifestFile.async("string");
      return JSON.parse(manifestContent) as ModrinthManifest;
    } catch (error) {
      throw new Error("Failed to read modpack file.");
    }
  }

  static async convert(file: File, manifest: ModrinthManifest, onProgress: ProgressCallback, options: ConversionOptions = { serverMode: false }): Promise<void> {
    const CACHE_NAME = "mrpack-mods-cache-v1";
    const cache = await caches.open(CACHE_NAME);

    const newZip = new JSZip();
    const originalZip = await JSZip.loadAsync(file);
    const limit = pLimit(5);

    const totalFiles = manifest.files.length;
    let completed = 0;

    onProgress("Copying overrides/configs...", 5);
    const overridesDir = "overrides";

    originalZip.folder(overridesDir)?.forEach((relativePath, zipEntry) => {
      if (!zipEntry.dir) {
        newZip.file(relativePath, zipEntry.async("blob"));
      }
    });

    if (options.serverMode) {
      onProgress("Generating server scripts...", 8);

      const batContent = `@echo off\nREM Auto-generated by MrPack Converter\njava -Xmx4G -jar server.jar nogui\nPAUSE`;
      newZip.file("start.bat", batContent);

      const shContent = `#!/bin/sh\n# Auto-generated by MrPack Converter\njava -Xmx4G -jar server.jar nogui`;
      newZip.file("start.sh", shContent, { unixPermissions: "755" });

      newZip.file("SERVER-README.txt", "Please rename your server jar (fabric/forge) to 'server.jar' before running the start script.");
    }

    const downloadPromises = manifest.files.map((modFile: ModrinthFile) => {
      return limit(async () => {
        const fileName = modFile.path.split("/").pop() || "unknown.jar";
        const downloadUrl = modFile.downloads[0];

        try {
          onProgress(`Downloading ${fileName}...`, 10 + (completed / totalFiles) * 80);

          let blob: Blob;
          const cachedResponse = await cache.match(downloadUrl);

          if (cachedResponse) {
            blob = await cachedResponse.blob();
          } else {
            const response = await fetch(downloadUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            cache.put(downloadUrl, response.clone());
            blob = await response.blob();
          }

          newZip.file(modFile.path, blob);
          completed++;
        } catch (err) {
          console.error(`Failed to download ${fileName}`, err);
          onProgress(`FAILED: ${fileName} (Skipping)`, 10 + (completed / totalFiles) * 80);
        }
      });
    });

    await Promise.all(downloadPromises);

    onProgress("Compressing final ZIP...", 95);
    const content = await newZip.generateAsync({ type: "blob" });

    onProgress("Done! Downloading...", 100);
    const suffix = options.serverMode ? "SERVER-PACK" : "FULL";
    saveAs(content, `${manifest.name}-${manifest.versionId}-${suffix}.zip`);
  }
}
